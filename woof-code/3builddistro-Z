#!/bin/bash
# new for fatdog style kernel

export LANG=C #faster.
export BUILDSYS=yes
export MWD=$(pwd)

. ./_00func
. ./_00build.conf

export PTHEME #build.conf - woof-code/rootfs-packages/ptheme
export XTRA_FLG # build.conf - extra naming for iso
KERNEL_REPO_URL=${KERNEL_REPO_URL:-http://distro.ibiblio.org/puppylinux/huge_kernels} #can change var

. ./DISTRO_SPECS      #this has DISTRO_VERSION.

source_compat_repos  # ./DISTRO_COMPAT_REPOS-
source_pkgs_specs    # ./DISTRO_PKGS_SPECS-
. ./PKGS_MANAGEMENT  #101013 want variable PKG_PREFER_OLDER.
. ./DISTRO_PET_REPOS #120506 want variable PACKAGELISTS_PET_ORDER
source_woofmergevars # ./WOOFMERGEVARS

create_local_repos_dirs
set_layer_type  # aufs or overlay
set_archdir_var # ex: ARCHDIR=x86_64-linux-gnu

#64 bit
[ "${DISTRO_BINARY_COMPAT}" = 'slackware64' ] && lsuffix=64 || lsuffix= #140121 for 64bit ${lsuffix} #170519 slacko specific

export DISTRO_NAME DISTRO_VERSION DISTRO_COMPAT_VERSION
export PUPPYSFS="puppy_${DISTRO_FILE_PREFIX}_${DISTRO_VERSION}.sfs"
export ZDRVSFS="zdrv_${DISTRO_FILE_PREFIX}_${DISTRO_VERSION}.sfs"
export FDRVSFS="fdrv_${DISTRO_FILE_PREFIX}_${DISTRO_VERSION}.sfs"
export ADRVSFS="adrv_${DISTRO_FILE_PREFIX}_${DISTRO_VERSION}.sfs"
export YDRVSFS="ydrv_${DISTRO_FILE_PREFIX}_${DISTRO_VERSION}.sfs"
export DEVXSFS="devx_${DISTRO_FILE_PREFIX}_${DISTRO_VERSION}.sfs"

#the files that have compatible-distro pkg docs (these were downloaded by 0setup)...
PKGLISTS_COMPAT="`echo "$PKG_DOCS_DISTRO_COMPAT" | tr ' ' '\n' | cut -f 3 -d '|' | tr '\n' ' ' | sed -e 's% $%%'`" #see file DISTRO_PKGS_SPECS-ubuntu
#...format ex: 'Packages-ubuntu-intrepid-main Packages-ubuntu-intrepid-universe'

export WKGDIR="`pwd`"

if [ "$BUILD_ZIP" = "yes" ]; then
	SDFLAG="zip"
elif [ "$DISTRO_TARGETARCH" = "arm" ]; then
	SDFLAG=1
fi

#w003 remove comments from PKGS_SPECS_TABLE
PKGS_SPECS_TABLE="`echo "$PKGS_SPECS_TABLE" | grep -v '^#'`"

mkdir -p sandbox3

#now build rootfs-complete, the main filesystem...
echo
echo "Now building sandbox3/rootfs-complete, with the complete filesystem..."
echo '#!/bin/sh' > sandbox3/pinstall.sh
rm -rf sandbox3/rootfs-complete
rm -rf sandbox3/devx
sync
mkdir -p sandbox3/rootfs-complete/etc
mkdir -p sandbox3/devx
cp DISTRO_SPECS sandbox3/rootfs-complete/etc/

#copy the skeleton...
cp -a rootfs-skeleton/* sandbox3/rootfs-complete/
cat sandbox3/rootfs-complete/pinstall.sh >> sandbox3/pinstall.sh

PKGSSPECS=DISTRO_PKGS_SPECS-${DISTRO_BINARY_COMPAT}-${DISTRO_COMPAT_VERSION}

# extra packages
CHOICE=/tmp/rootfs_choice$$
if [ -f support/rootfs-packages.conf ];then
	cp -a support/rootfs-packages.conf $CHOICE
elif ! grep 'yes|xorg' $PKGSSPECS ; then #cli-only build
	echo -e "\nCLI-ONLY BUILD, NOT INCLUDING EXTRA PACKAGES ...\n"
	(
	for d in $(ls rootfs-packages) ; do
		echo "$d=\"false\""
	done
	) > $CHOICE
else
	echo -e "\nAUTO SELECTING EXTRA PACKAGES ...
If you know what extra packages you want
you can bypass this automatic selection, by renaming:
	'support/rootfs-packages.conf-backup'
to
	'support/rootfs-packages.conf'
and edit it to include your customised package list.
"
	(
	for d in $(ls rootfs-packages)
	do  
		case "$d" in
		rox_config)
			state=false
			grep -q 'yes|rox.*filer|' $PKGSSPECS && state=true
			;;
		jwm_config|ptheme|pt_*)
			if grep -q 'yes|jwmconfig' $PKGSSPECS ; then
				state=false #cant choose them if jwmconfig is in specs. 
			elif grep -q 'yes|jwm|' $PKGSSPECS ; then
				state=true
			fi
			;;
		pmusic)
			state=false
			grep -q 'yes|ffmpeg' $PKGSSPECS && state=true
			grep -q 'yes|pcd|' $PKGSSPECS && state=false
			;;		
		cups_backend*) # contains the backends smbw and pdf-writer
			state=false
			grep -q 'yes|cups|' $PKGSSPECS && state=true
			;;
		*)
			state=true
			grep -q "yes|${d}|" $PKGSSPECS && state=false # don't overwrite user chosen specs
			;;
		esac
		echo "$d=\"$state\""
	done
	) > $CHOICE
	#cat $CHOICE
fi

. $CHOICE
[ -f /tmp/rootfs-packages.specs ] && rm /tmp/rootfs-packages.specs # in case we baled out on last build
[ -f /tmp/rootfs_pkgs_pinstall.sh ] && rm /tmp/rootfs_pkgs_pinstall.sh # this needs doing anyway

while read line
do 
	rpkg=${line%%=*}
	if echo $line | grep -q "false" ;then
		continue
	fi
	if [ ! -d rootfs-packages/${rpkg} ] ; then
		echo "* rootfs-packages/${rpkg} does not exist"
		continue
	fi
	echo "copying ${line%%=*}"
	cp -a rootfs-packages/${rpkg}/* sandbox3/rootfs-complete/
	if [ -f rootfs-packages/${rpkg}/pinstall.sh ];then
		if grep -qw 'exit' rootfs-packages/${rpkg}/pinstall.sh;then
			continue
		fi
		if grep -q 'poor man' rootfs-packages/${rpkg}/pinstall.sh;then # ptheme must go last
			cat rootfs-packages/${rpkg}/pinstall.sh > /tmp/rootfs_pkgs_pinstall_ptheme.sh
		else
			(
			echo -e "\n#== ${line%%=*}/pinstall.sh ==\n"
			cat rootfs-packages/${rpkg}/pinstall.sh
			) >> /tmp/rootfs_pkgs_pinstall.sh
		fi
	fi
	cat sandbox3/rootfs-complete/pet.specs >> /tmp/rootfs-packages.specs
done < $CHOICE
cat /tmp/rootfs_pkgs_pinstall_ptheme.sh >> /tmp/rootfs_pkgs_pinstall.sh

rm $CHOICE
#creates devx-only-installed-packages.
./support/findwoofinstalledpkgs # moved to here so we can add /tmp/rootfs-packages.specs

### new {a,f,y}drv stuff - this creates a full 'woof-installed-packages' in {a,y}drv and subtracts the
# {a,y}drv installed packages from the the full 'woof-installed-packages' that goes to the main sfs.
if [ "$(echo $ADRV_INC)" != "" -o "$(echo $FDRV_INC)" != "" -o "$(echo $YDRV_INC)" != "" ];then 
	sync
	fields="${ADRV_INC}:${FDRV_INC}:${YDRV_INC}:)"
	IFS=':' read -a field <<< $fields
	fcnt=0
	for dtype in a f y; do
		[ -d sandbox3/${dtype}drv ] && rm -rf sandbox3/${dtype}drv
		[ "$dtype" = 'a' -a -z "$ADRV_INC" ] && continue
		[ "$dtype" = 'f' ] && continue #don't bother with fdrv
		[ "$dtype" = 'y' -a -z "$YDRV_INC" ] && break
		mkdir -p sandbox3/${dtype}drv${PACKAGES_DIR}/
		[ -f /tmp/${dtype}-woof-packages ] && rm /tmp/${dtype}-woof-packages
		while read -r line
		do 
			IFS='|' read -r a b c <<<$line
			if echo "${fields[${fcnt}]}" | grep -q "$b" ;then
				continue
			else
				echo "$line" >> /tmp/${dtype}-woof-packages
			fi
		done < woof-installed-packages
		cat woof-installed-packages > sandbox3/${dtype}drv${PACKAGES_DIR}/woof-installed-packages
		cat /tmp/${dtype}-woof-packages > woof-installed-packages
		fcnt=$(($fcnt + 1))
	done
fi
###
rm -f sandbox3/rootfs-complete/pinstall.sh

#=====================================================================
function files2delete() {
	[ -d "$1" ] || return
	(
		cd "$1"
		echo
		echo "Parsing  support/files2delete"
		while read i ; do
			for file in $(echo ./$i) #might cointain wildcards
			do
				[ -f ${file} ] && rm -fv ${file}
			done
		done < ${MWD}/support/files2delete
		#--
		if [ "${DISTRO_BINARY_COMPAT}" = 'slackware64' ] ; then
			sed 's%/lib/%/lib64/%' ${MWD}/support/files2delete > ${MWD}/support/files2delete64
			while read i ; do
				for file in $(echo ./$i) #might cointain wildcards
				do
					[ -f ${file} ] && rm -fv ${file}
				done
			done < ${MWD}/support/files2delete64
		fi
		if [ "$ARCHDIR" ] ; then
			sed "s%/lib/%/lib/${ARCHDIR}/%" ${MWD}/support/files2delete > ${MWD}/support/files2delete${ARCHDIR}
			while read i ; do
				for file in $(echo ./$i) #might cointain wildcards
				do
					[ -f ${file} ] && rm -fv ${file}
				done
			done < ${MWD}/support/files2delete${ARCHDIR}
		fi
		echo
	)
}

function copy_pkgs_to_build() {
	. ./DISTRO_SPECS
	SFS_DIR=$2
	case $SFS_DIR in
		*drv) xPRE=${SFS_DIR:0:1};; #extract first char: a, y, z, f ...
		*)    xPRE=''            ;;
	esac
	#--
	while read ONEPKG
	do
	case $SFS_DIR in adrv|ydrv)
		if ls rootfs-packages | grep -q "${ONEPKG}" ;then
			echo -n " ${ONEPKG}"
			cp -a --remove-destination rootfs-packages/${ONEPKG}/* sandbox3/${SFS_DIR}/ 2> /tmp/3builddistro-cp-errlog
			continue
		fi
		;;
	esac
	if [ ! -d packages-${DISTRO_FILE_PREFIX}/${ONEPKG} ];then
		if [ ! -d packages-${DISTRO_FILE_PREFIX}/${ONEPKG}_DEV ];then #pkg may go entirely into devx.
			if [ ! -d packages-${DISTRO_FILE_PREFIX}/${ONEPKG}_DOC ];then #pkg may go entirely into docs.
				echo "WARNING, PKG DOES NOT EXIST: packages-${DISTRO_FILE_PREFIX}/${ONEPKG}"
				continue
			fi
		fi
	fi
	case "$ONEPKG" in
		busybox|busybox_static|busybox-static) continue ;; #busy box may conflict with core apps
		sfs_load|xkbconfigmanager) continue;; #force woofce apps
	esac
	echo -n " ${ONEPKG}"
	cp -a --remove-destination packages-${DISTRO_FILE_PREFIX}/${ONEPKG}/* sandbox3/${SFS_DIR}/ 2> /tmp/3builddistro-cp-errlog
	sync
	if [ -f sandbox3/${SFS_DIR}/pinstall.sh ];then
		#note, do not filter #! /bin/sh (with a space)...
		(
		echo -e "\n#== packages-${DISTRO_FILE_PREFIX}/${ONEPKG} ==\n"
		grep  -E -v '^\#\!\/bin\/sh' sandbox3/${SFS_DIR}/pinstall.sh
		) >> sandbox3/${xPRE}pinstall.sh
		rm -f sandbox3/${SFS_DIR}/pinstall.sh
	fi
	#get rid of .specs file...
	rm -f sandbox3/${SFS_DIR}/*.specs
	done <<< "$(echo "$1" | tr ' ' '\n')"
	#--
}
#=====================================================================

echo "Copying to sandbox3/rootfs-complete..."
EXTRAS_LIST="${ADRV_INC// /|} ${YDRV_INC// /|} ${AFDRV_INC// /|}"
if echo "$EXTRAS_LIST" | grep -qvE "[a-z]";then
	DUMMY="" 
else
	DUMMY=XXXX #unless they make a Qld beer proggy 'XXXX' will never match; besides need a trailing field
	EXTRAS_LIST="${EXTRAS_LIST// /|}${DUMMY}"
	EXTRAS_LIST="${EXTRAS_LIST//^|}" #strip leading "|"
	EXTRAS_LIST="${EXTRAS_LIST//||/|}" #replace double "||" with "|"
fi
if [ -n "${DUMMY}" ];then
	PKGLIST="`echo "$PKGS_SPECS_TABLE" | grep '^yes' | grep -vE "${EXTRAS_LIST}" | cut -f 2 -d '|' | tr '\n' ' '`" 
else
	PKGLIST="`echo "$PKGS_SPECS_TABLE" | grep '^yes' | cut -f 2 -d '|' | tr '\n' ' '`"
fi
PKGLIST="${PKGLIST}"
copy_pkgs_to_build "${PKGLIST}" rootfs-complete
echo

### new {a,f,y}drv build - this sorts the packages and builds the {a,f,y}drv filesystem
ADRV_INCLUDE='';FDRV_INCLUDE_='';YDRV_INCLUDE=''
[ "$(echo $ADRV_INC)" != "" ] && ADRV_INCLUDE=adrv
[ "$(echo $FDRV_INC)" != "" ] && FDRV_INCLUDE=fdrv
[ "$(echo $YDRV_INC)" != "" ] && YDRV_INCLUDE=ydrv
if [ -n "$ADRV_INCLUDE" -o -n "$FDRV_INCLUDE" -o -n "$YDRV_INCLUDE" ];then
	rm -f sandbox3/?pinstall.sh
	for _DRV in  $ADRV_INCLUDE $FDRV_INCLUDE $YDRV_INCLUDE;do
		echo
		echo "Now building sandbox3/${_DRV} with apps redirected to ${_DRV}_${DISTRO_FILE_PREFIX}_${DISTRO_VERSION}.sfs"
		case ${_DRV} in
		adrv)
			echo '#!/bin/sh' > sandbox3/apinstall.sh
			mkdir -p sandbox3/adrv/usr/local/bin
			copy_pkgs_to_build "${ADRV_INC}" adrv
			chmod 755 sandbox3/apinstall.sh
			echo;;
		fdrv)
			echo '#!/bin/sh' > sandbox3/fpinstall.sh
			mkdir -p sandbox3/fdrv/
			copy_pkgs_to_build "${FDRV_INC}" fdrv
			chmod 755 sandbox3/fpinstall.sh
			echo
			CONF_DIR=no;;
		ydrv)
			echo '#!/bin/sh' > sandbox3/ypinstall.sh
			mkdir -p sandbox3/ydrv/usr/local/bin
			copy_pkgs_to_build "${YDRV_INC}" ydrv
			chmod 755 sandbox3/ypinstall.sh
			echo;;
		esac
		# if exists in {a,y}drv a .desktop file we symlink it to root/.config/rox.sourceforge.net/OpenWith/
		if [ ! "$CONF_DIR" = 'no' ];then
			mkdir -p sandbox3/${_DRV}/root/.config/rox.sourceforge.net/OpenWith/
			(
			cd sandbox3/${_DRV}/root/.config/rox.sourceforge.net/OpenWith/
			for d in ../../../../usr/share/applications/*.desktop;do
				app=${d##*/}
				lo=$app # weird bug with libreoffice*.desktop 'permission denied'
				app=${app%\.*}
				if echo $app | grep -q 'libreoffice';then
					echo $app | grep -qE "qstart|startcenter|xsltfilter" && continue
					ln -sf $d $lo # maintains '.desktop' extension
				else
					ln -sf $d $app
				fi
			done
			)
		fi
	done
else
	rm -rf sandbox3/?drv #precaution
fi
### end {a,f,y}drv

#some old packages have xpm and png images in /
mv -f sandbox3/rootfs-complete/{*.xpm,*.png} sandbox3/rootfs-complete/usr/share/pixmaps 2>/dev/null

# fix busybox applets...
cp -a -f packages-${DISTRO_FILE_PREFIX}/busybox/bin/busybox ./sandbox3/rootfs-complete/bin/
for ONEAPPLET in `find packages-${DISTRO_FILE_PREFIX}/busybox -type l | tr '\n' ' '`
do
	ONESPEC="`echo -n "$ONEAPPLET" | sed -e "s%packages-${DISTRO_FILE_PREFIX}/busybox%%"`"
	ONEPATH="`dirname $ONESPEC`"
	ONENAME="${ONESPEC##*/}" #basename $ONESPEC
	FNDFULL="`find ./sandbox3/rootfs-complete/bin ./sandbox3/rootfs-complete/sbin ./sandbox3/rootfs-complete/usr/bin ./sandbox3/rootfs-complete/usr/sbin -name ${ONENAME}`"
	if [ ! "$FNDFULL" ];then #need to check in devx also...
		case ${ONENAME} in ar|man|patch|strings)
			FNDFULL="${ONENAME}" ;;
		esac
	fi
	if [ "$FNDFULL" ];then
		cp -a -f $ONEAPPLET ./sandbox3/rootfs-complete${ONEPATH}/${ONENAME}-BB
	else
		cp -a -f $ONEAPPLET ./sandbox3/rootfs-complete${ONEPATH}/
	fi
done
[ -f packages-${DISTRO_FILE_PREFIX}/busybox/pinstall.sh ] && cat packages-${DISTRO_FILE_PREFIX}/busybox/pinstall.sh >> sandbox3/pinstall.sh
[ -f /tmp/rootfs_pkgs_pinstall.sh ] && cat /tmp/rootfs_pkgs_pinstall.sh >> sandbox3/pinstall.sh

rm -f /tmp/3builddistro_end_of_pinstall
echo -e '\ntouch /tmp/3builddistro_end_of_pinstall' >> sandbox3/pinstall.sh
chmod 755 sandbox3/pinstall.sh

#pemasu start 131207
echo "Removing extra documentation"
for i in sandbox3/rootfs-complete/usr/share/doc/*; do
	if [ -d $i ]; then
		keep=0
		for j in legal pmusic pburn pbackup mtpaint help wvdial ffconvert cups nls puplogos notecase didiwiki xarchive; do #140128 added back legal, 01micko
			case `basename $i` in $j) keep=1 ; break 1 ;; esac
		done
		[ $keep -eq 0 ] && rm -rf $i
	fi
done
for i in share/doc share/info share/man usr/share/info usr/share/man \
	usr/share/gtk-doc usr/share/gnome/help usr/info usr/man usr/share/cups/doc-root/help
do
	if [ -d sandbox3/rootfs-complete/${i} ] ; then
		rm -rf sandbox3/rootfs-complete/${i}
		mkdir -p sandbox3/rootfs-complete/${i}
	fi
done

echo "Removing extra locales"
for i in sandbox3/rootfs-complete/usr/share/locale/*; do
	if [ -d $i ]; then
		keep=0
		for j in en en_US locale.alias; do
			case `basename $i` in $j) keep=1 ; break 1 ;; esac
		done
		[ $keep -eq 0 ] && rm -rf $i
	fi
done
#pemasu end

#run post-install script...
echo
echo "Executing sandbox3/pinstall.sh post-install script..."
cd $WKGDIR/sandbox3/rootfs-complete
SAVEWKGDIR="$WKGDIR"
$WKGDIR/sandbox3/pinstall.sh
### new {a,f,y}drv stuff - execute the '{a,f,y}pinstall.sh'
(
cd $WKGDIR/sandbox3/
for post_inst in adrv fdrv ydrv;do
	prefix=${post_inst:0:1}
	[ -f ${prefix}pinstall.sh ] && {(cd ${post_inst};$WKGDIR/sandbox3/${prefix}pinstall.sh)}
done
)
###
echo "Now setting /etc/os-release file"
mk_os_release() {
	dir=/etc
	[ "$1" ] && dir=etc
	 . $dir/DISTRO_SPECS
	
	cat > ${dir}/os-release << _EOF
NAME=Puppy
VERSION="$DISTRO_VERSION"
ID=puppy_$DISTRO_FILE_PREFIX
VERSION_ID=$DISTRO_VERSION
PRETTY_NAME="$DISTRO_NAME $DISTRO_VERSION"
ANSI_COLOR="0;34"
CPE_NAME="cpe:/o:puppy:puppy_linux:$DISTRO_VERSION"
HOME_URL="http://puppylinux.com/"
SUPPORT_URL="http://www.murga-linux.com/puppy/index.php"
BUG_REPORT_URL="https://github.com/puppylinux-woof-CE/woof-CE"
_EOF
}
mk_os_release ok

if [ -f /tmp/3builddistro_end_of_pinstall ] ; then
	echo "pinstall.sh finished OK"
	sleep 2
else
	echo -n "pinstall.sh aborted before completion. Press ENTER or CTRL-C: "
	read isitbad
fi

WKGDIR="$SAVEWKGDIR"
cd $WKGDIR

# new profile script fixup
support/mk_profile

#==========
cd sandbox3
#==========

sync
#now do the kernel...
echo
rm -rf build 2>/dev/null
mkdir build

if [ "$DISTRO_KERNEL_PET" = 'Raspbian_Kernel' ];then
	# do nothing.
	echo -n #-------
elif [ "$DISTRO_KERNEL_PET" = 'Kit_Kernel' ];then
	../support/kit_kernel.sh || exit 1
else
	# Huge_Kernel
	../support/huge_kernel.sh || exit 1
fi

#========================

rootfs=rootfs-complete

REALKERNAME='vmlinuz'
[ -f ${rootfs}/boot/vmlinuz* ] && mv ${rootfs}/boot/vmlinuz* build/vmlinuz
if [ -f ${rootfs}/boot/uImage ];then #mele a1000
	cp ${rootfs}/boot/uImage build/vmlinuz #120506 arm builds, using different name for kernel.
	REALKERNAME='uImage'
elif [ -f ${rootfs}/boot/kernel.img ];then #raspberry pi
	cp ${rootfs}/boot/kernel.img build/vmlinuz
	REALKERNAME='kernel.img'
elif [ -f ${rootfs}/boot/kernel7.img ];then #raspberry pi2
	cp ${rootfs}/boot/kernel7.img build/vmlinuz7
	REALKERNAME='kernel.img'
elif [ -f ${rootfs}/boot/vmlinuz-*-rpi ];then #raspberry pi, Raspbian kernel
	mv ${rootfs}/boot/vmlinuz-*-rpi build/vmlinuz
	REALKERNAME='kernel.img'
elif [ -f ${rootfs}/boot/vmlinuz-*-rpi2 ];then #raspberry pi2, Raspbian kernel
	mv ${rootfs}/boot/vmlinuz-*-rpi2 build/vmlinuz7
	REALKERNAME='kernel.img'
fi
[ -f ${rootfs}/boot/System.map ] && cp ${rootfs}/boot/System.map ./
sync

#build the initrd-tree...
echo
echo "Now building initial ramdisk..."
cp ../DISTRO_SPECS rootfs-complete/etc/DISTRO_SPECS

if [ "$DISTRO_KERNEL_PET" = 'Kit_Kernel' ];then
	NEWVARIABLES="DISTRO_ZDRVSFS=\"kernel-modules-\$(uname -r)-${DISTRO_FILE_PREFIX}.sfs\""
else
	#100911
	NEWVARIABLES="#Puppy default filenames...
#Note, the 'SFS' files below are what the 'init' script in initrd.gz searches for,
#for the partition, path and actual files loaded, see PUPSFS and ZDRV in /etc/rc.d/PUPSTATE
DISTRO_PUPPYSFS='${PUPPYSFS}'
DISTRO_ZDRVSFS='${ZDRVSFS}'
DISTRO_FDRVSFS='${FDRVSFS}'
DISTRO_ADRVSFS='${ADRVSFS}'
DISTRO_YDRVSFS='${YDRVSFS}'"
fi
echo "$NEWVARIABLES" >> rootfs-complete/etc/DISTRO_SPECS

DISTRO_PUPPYDATE="`date | tr -s " " | cut -f 2,6 -d " "`"
echo "DISTRO_PUPPYDATE='${DISTRO_PUPPYDATE}'" >> rootfs-complete/etc/DISTRO_SPECS

#### initrd-progs #### build/initrd.gz...
cp rootfs-complete/etc/DISTRO_SPECS ../initrd-progs/DISTRO_SPECS

rm -f build/initrd.[gx]z ../initrd-progs/initrd.[gx]z
(
	cd ../initrd-progs/
	./build.sh -prebuilt -auto -arch ${WOOF_TARGETARCH:-default} ${INITRD_LANG} ${INITRD_KM}
)
mv -f ../initrd-progs/initrd.[gx]z build/
if [ ! -f build/initrd.gz -a ! -f build/initrd.xz ] ; then
	echo "No initrd... exiting"
	exit 1
fi

if [ "$SDFLAG" ] ; then
	cp -fv ../initrd-progs/ZZ_initrd-expanded/bin/busybox rootfs-complete/bin/busybox_static
	cp -fv ../initrd-progs/ZZ_initrd-expanded/bin/e2fsck rootfs-complete/sbin/e2fsck_static
fi

# Include LICK installer
if [ "$LICK_IN_ISO" = "yes" ]; then
	../support/lick_in_iso.sh
fi

rm -rf zdrv ${ZDRVSFS} 2>/dev/null #note, current dir is in sandbox3.

#100622 slackware 13.1: just in case any got through, remove c-shell scripts...
rm -f rootfs-complete/etc/profile.d/*.csh* 2>/dev/null

#sanity check...
echo
if [ "$WOOF_HOSTARCH" = "$WOOF_TARGETARCH" ];then #111123
	chroot rootfs-complete echo 'testing chroot'
	if [ $? -ne 0 ];then
		echo "ERROR: could not 'chroot' into sandbox3/rootfs-complete"
		echo "This means that something is incomplete, perhaps a library"
		echo "needed by bash. Check it out. Have to exit script now."
		exit
	fi
else
	echo "*** Doing a cross-build. Not chrooting to do a sanity-test ***"
fi

#get info about the ubuntu pkgs...
echo "Updating pkg data in rootfs-complete${PACKAGES_DIR} ..."
#copy them into the live-cd also...
for ONELIST in $PKGLISTS_COMPAT $PACKAGELISTS_PET_ORDER
do
	cp -f ../$ONELIST ./
	cp -fv ../$ONELIST rootfs-complete${PACKAGES_DIR}/
done

#also copy the pet package databases...
cp -f ../Packages-puppy-noarch-official rootfs-complete${PACKAGES_DIR}/ #120305

if [ -f ../Packages-puppy-${DISTRO_DB_SUBNAME}-official ];then #110723 ex: Packages-puppy-drake-official
	cp -f ../Packages-puppy-${DISTRO_DB_SUBNAME}-official rootfs-complete${PACKAGES_DIR}/
fi

#also copy this...
cp -f ../PKGS_MANAGEMENT rootfs-complete${PACKAGES_DIR}/

#477 a puppy-puppy build will not have any compat-distro databases...
petcntlimit=3
COMPATDISTRO_DB_FILES="`ls -1 rootfs-complete${PACKAGES_DIR}/Packages-[^p]* 2>/dev/null`"
[ "$COMPATDISTRO_DB_FILES" = "" ] && petcntlimit=5
enabledrepos=" "
repocnt=1

case $DISTRO_FILE_PREFIX in  #110906 fix. $DISTRO_COMPAT_VERSION in #100911
	slacko*) enabledrepos="Packages-puppy-${DISTRO_DB_SUBNAME}-official Packages-puppy-noarch-official " ;;
	*)
		#add the puppy repos... (i want 5, 4, 3)...
		for ONEREPO in `ls -1 rootfs-complete${PACKAGES_DIR}/Packages-puppy* | sort -r`
		do
			[ $repocnt -gt $petcntlimit ] && break #limit of 3 puppy repos.
			BASEREPO=${ONEREPO##*/} #basename $ONEREPO
			case $BASEREPO in Packages-puppy-common*) continue ;; esac
			enabledrepos="${enabledrepos}${BASEREPO} "
			repocnt=`expr $repocnt + 1`
		done
		;;
esac

#add compat-distro repos...
if [ "$COMPATDISTRO_DB_FILES" != "" ];then
	for ONEREPO in `ls -1 rootfs-complete${PACKAGES_DIR}/Packages-[^p]*`
	do
		[ $repocnt -gt 5 ] && break #only allow 5 active repos in PPM.
		BASEREPO="`basename $ONEREPO`"
		enabledrepos="${enabledrepos}${BASEREPO} "
		repocnt=`expr $repocnt + 1`
	done
fi

#120831 above code ok, but really just want these...
case $DISTRO_BINARY_COMPAT in ubuntu|trisquel)
	xPUPPYREPOS="Packages-puppy-${DISTRO_DB_SUBNAME}-official Packages-puppy-noarch-official" #Packages-puppy-common-official 
	xCOMPATREPOS="$(ls -1 rootfs-complete${PACKAGES_DIR}/Packages-[^p]* | grep -E '\-main$|\-universe$|\-multiverse$' | rev | cut -f 1 -d '/' | rev | tr '\n' ' ')"
	#130330 would like universe first...
	xCOMPATREPOS1="$(ls -1 rootfs-complete${PACKAGES_DIR}/Packages-[^p]* | grep -E '\-universe$' | rev | cut -f 1 -d '/' | rev | tr '\n' ' ')"
	xCOMPATREPOS2="$(ls -1 rootfs-complete${PACKAGES_DIR}/Packages-[^p]* | grep -E '\-main$|\-multiverse$' | rev | cut -f 1 -d '/' | rev | tr '\n' ' ')"
	enabledrepos=" ${xCOMPATREPOS1} ${xCOMPATREPOS2} ${xPUPPYREPOS} "
esac

echo "PKG_REPOS_ENABLED='${enabledrepos}'" >> rootfs-complete${PACKAGES_DIR}/PKGS_MANAGEMENT

cp -f ../${DPSFILE} rootfs-complete${PACKAGES_DIR}/DISTRO_PKGS_SPECS   # _00func
cp -f ../${DCRFILE} rootfs-complete${PACKAGES_DIR}/DISTRO_COMPAT_REPOS # _00func

#=
cp -f ../DISTRO_PET_REPOS rootfs-complete${PACKAGES_DIR}/DISTRO_PET_REPOS-orig
# make common* pet repos insivible to the PPM..
sed '/Packages-puppy-common/d' rootfs-complete${PACKAGES_DIR}/DISTRO_PET_REPOS-orig \
	> rootfs-complete${PACKAGES_DIR}/DISTRO_PET_REPOS
#=

if [ -f ../PKGS_HOMEPAGES ] ; then
	cp -f ../PKGS_HOMEPAGES rootfs-complete${PACKAGES_DIR}/
else
	touch rootfs-complete${PACKAGES_DIR}/PKGS_HOMEPAGES
fi

cat <<EOF>/tmp/conf_spacer

#  >>>> rootfs-packages.conf >>>>
EOF
cat ../_00build.conf /tmp/conf_spacer ../rootfs-packages.conf > rootfs-complete${PACKAGES_DIR}/woof-build.conf
rm -f /tmp/conf_spacer
#this needed to update pkg db's in a running puppy...
cp -f ../0setup rootfs-complete/usr/local/petget/

touch ../invaliddepslist
cp -f ../invaliddepslist rootfs-complete/usr/local/petget/

#findwoofinstalledpkgs creates 'woof-installed-packages'
cp ../woof-installed-packages rootfs-complete${PACKAGES_DIR}/ #already created earlier
touch ../devx-only-installed-packages #121028
cp ../devx-only-installed-packages rootfs-complete${PACKAGES_DIR}/ #121028

#110722 add kernel db line...
echo "$KERNEL_DB_ENTRY" >> rootfs-complete${PACKAGES_DIR}/woof-installed-packages
#sort alphabetically...
sort --key=1 --field-separator="|" rootfs-complete${PACKAGES_DIR}/woof-installed-packages > /tmp/petget_woof-installed-packages
mv -f /tmp/petget_woof-installed-packages rootfs-complete${PACKAGES_DIR}/woof-installed-packages

# certain utilities are not appropriate when booting on an arm board...
if [ "$SDFLAG" ];then
	for i in usr/sbin/grubconfig usr/sbin/remasterpup2 \
		usr/share/applications/Grub-bootloader-config.desktop \
		usr/share/applications/BootFlash-usb-installer.desktop \
		usr/share/applications/Puppy-universal-installer.desktop \
		usr/share/applications/Remaster-Puppy-live-CD.desktop
	do rm -f rootfs-complete/${i} ; done
	if [ "$SDFLAG" != "zip" ]; then
		rm -f rootfs-complete/usr/sbin/resizepfile.sh
	fi
fi

#130326 script to adjust fonts to suit 96 dpi (puppy used to have 78 dpi)...
[ ! -d rootfs-complete/usr/share/ptheme ] && rootfs-complete/usr/sbin/hackfontsize #don't execute if we have ptheme

#shared library loading...
( # > rootfs-complete/etc/ld.so.conf
	echo "/lib${lsuffix}"
	echo "/usr/lib${lsuffix}"
	if [ "$ARCHDIR" = "x86_64-linux-gnu" ] ; then #WOOF_TARGETARCH='x86_64'
		echo "/lib64"
		echo "/usr/lib64"
		echo -e "/lib64\n/usr/lib64" > rootfs-complete/etc/ld.so.conf.d/lib64.conf
	fi
	[ -d rootfs-complete/usr/local/lib${lsuffix} ] && echo "/usr/local/lib${lsuffix}"
	[ -d rootfs-complete/opt/qt4/lib${lsuffix} ] && echo "/opt/qt4/lib${lsuffix}"
	echo "/root/my-applications/lib"
) > rootfs-complete/etc/ld.so.conf

echo "Updating system config.."
rm -rf rootfs-complete/var/cache/fontconfig
mkdir -p rootfs-complete/var/cache/fontconfig
if [ "$WOOF_HOSTARCH" = "$WOOF_TARGETARCH" ];then
	chroot rootfs-complete /etc/rc.d/rc.update w
	# create a table for dialog/Xdialog: /usr/share/i18n/dialog_table
	# 'chooselocale' is called from /etc/rc.d/rc.country at first boot and
	# pre-creating this table speeds things up. 111123
	chroot rootfs-complete /usr/sbin/chooselocale composeonly
else
	#*** cross-build
	touch rootfs-complete/etc/gtk-2.0/gtk.immodules
	( cd rootfs-complete ; XDG_DATA_HOME=./usr/share update-mime-database ./usr/share/mime/ )
	( cd rootfs-complete ; fc-cache -s -v -y $(pwd) usr/share/fonts )
fi

#w460 theme selection...
# if "default.ext" exists in wallpapers then we set it up in poor man's ptheme...
wdefault=`find rootfs-complete/usr/share/backgrounds -name 'default.*'`
wptheme=`find rootfs-complete/usr/share/ -type d -name 'ptheme'`
if [ -z "$wdefault" -a -z "$wptheme" ];then #it don't exists so we proceed with this method 
	. ../support/choose_themes
	#...returns BACKGROUNDIMAGE, DESKICONS, GTKTHEME, JWMTHEME.
fi

if [ -f rootfs-complete/etc/desktop_icon_theme ] ; then
	DESKICONS=`cat rootfs-complete/etc/desktop_icon_theme` # set up by poor man's ptheme
fi
if [ "${GTKTHEME}" ] && [ -d rootfs-complete/usr/share/themes/${GTKTHEME} ] ; then
	pathGTK3THEME="`find rootfs-complete/usr/share/themes/${GTKTHEME} -type d -name gtk-3.0`"
	[ "$pathGTK3THEME" ] && ln -snf "$pathGTK3THEME" rootfs-complete/root/.config/gtk-3.0
fi

NEWTHEME="$DESKICONS" #see above
(
	cd rootfs-complete
	./usr/sbin/icon_switcher -sysroot . -a ${NEWTHEME}
)

#111006 generic logo mechanism for all pups...
for logosize in 48 96 ; do
	if [ -f rootfs-complete/usr/share/doc/puplogos/${DISTRO_FILE_PREFIX}${logosize}.png ];then
		mv -f rootfs-complete/usr/share/doc/puplogos/${DISTRO_FILE_PREFIX}${logosize}.png rootfs-complete/usr/share/doc/${DISTRO_FILE_PREFIX}${logosize}.png
		ln -snf ${DISTRO_FILE_PREFIX}${logosize}.png rootfs-complete/usr/share/doc/puppylogo${logosize}.png
	fi
done
rm -rf rootfs-complete/usr/share/doc/puplogos

#w481 extra stripping...
if [ "$WOOF_HOSTARCH" = "$WOOF_TARGETARCH" ] && [ "`which strip`" = "" ] ; then
	extra_strip() {
		echo -n "${ONEFILE##*/} " #basename "$ONEFILE"
		FILE_INFO=$(file "$ONEFILE")
		case $FILE_INFO in *"ELF"*)
			case $FILE_INFO in
				*"executable"*|*"shared object"*) strip --strip-unneeded "$ONEFILE" ;;
			esac
		esac
	}
	find rootfs-complete/bin rootfs-complete/sbin rootfs-complete/usr/bin rootfs-complete/sbin -type f |
	while read ONEFILE ; do extra_strip ; done
	echo
	find rootfs-complete/lib${lsuffix} rootfs-complete/usr/lib${lsuffix} -type f -name \*.so* |
	while read ONEFILE ; do extra_strip ; done
	echo
fi

#=================================================
. ../support/builtin_files.sh # /tmp/rootfs-packages.specs
#=================================================

#120224 move rootfs-complete/usr/share/doc/nls to 'devx'...
mkdir -p devx/usr/share/doc/nls
cp -a -f rootfs-complete/usr/share/doc/nls/* devx/usr/share/doc/nls/
rm -r -f rootfs-complete/usr/share/doc/nls

#110429 this is difficult. may need a fix, think want glibc scsi headers in usr/include/scsi...
mkdir -p devx/usr/include
if [ -d ../packages-${DISTRO_FILE_PREFIX}/linux_headers_DEV/usr/include/scsi ];then
	cp -a ../packages-${DISTRO_FILE_PREFIX}/linux_headers_DEV/usr/include/scsi devx/usr/include/scsi-KERNEL
fi
if [ -d ../packages-${DISTRO_FILE_PREFIX}/linux-header_DEV/usr/include/scsi ];then
	cp -a ../packages-${DISTRO_FILE_PREFIX}/linux-header_DEV/usr/include/scsi devx/usr/include/scsi-KERNEL
fi
if [ -d ../packages-${DISTRO_FILE_PREFIX}/glibc_DEV/usr/include/scsi ];then
	cp -a ../packages-${DISTRO_FILE_PREFIX}/glibc_DEV/usr/include/scsi devx/usr/include/scsi-GLIBC
fi
#also see further down, when building devx.

#110822 some customisations provided by 01micko for Slacko...
if [ "${DISTRO_FILE_PREFIX:0:6}" = "slacko" ];then #130321 #161008 fix for 64
	if [ -f ../support/slacko/woof_base_hack  ];then
		echo "Running Slacko customization script ../support/slacko/woof_base_hack..."
		../support/slacko/woof_base_hack
	fi
fi

#111123 put this into target, want to know if cross-build at 1st boot (see rc.update)...
[ -f ../WOOFMERGEVARS ] && cp -f ../WOOFMERGEVARS rootfs-complete/etc/rc.d/

#120704 some constraints in a small system...
if [ "$SDFLAG" != "" ];then
	#this also reduces writes to flash card... um, relatime seems to be the default anyway... 120707 change to noatime...
	echo "BOOT_ATIME='noatime'" >> rootfs-complete/etc/rc.d/BOOTCONSTRAINED #rc.sysinit will remount / with 'relatime' (constrains updating access time). 120707 change to noatime.
	echo "BOOT_DIRTYWRITE='1500'" >> rootfs-complete/etc/rc.d/BOOTCONSTRAINED #defer writing to disk. refer: http://www.lesswatts.org/tips/disks.php
	echo "BOOT_SCHEDULER='deadline'" >> rootfs-complete/etc/rc.d/BOOTCONSTRAINED #my kernel defaults to 'cfq', change to 'deadline'. refer: http://tombuntu.com/index.php/2008/09/04/four-tweaks-for-using-linux-with-solid-state-drives/
	echo "BOOT_UDEVDCHILDREN='1'" >> rootfs-complete/etc/rc.d/BOOTCONSTRAINED #120709 is this a good idea? append --children-max=1 to udevd in rc.sysinit.
	echo "BOOT_BOARD='${BOOT_BOARD}'" >> rootfs-complete/etc/rc.d/BOOTCONSTRAINED #120714 read by quicksetup.
fi
echo '#multiarch distros, such as Ubuntu, will have this. ex: /usr/lib/i386-linux-gnu, so DISTRO_ARCHDIR=i386-linux-gnu' >> rootfs-complete/etc/DISTRO_SPECS
echo "DISTRO_ARCHDIR='${ARCHDIR}'" >> rootfs-complete/etc/DISTRO_SPECS
echo "DISTRO_ARCHDIR='${ARCHDIR}'" >> initrd-tree/DISTRO_SPECS

if grep -q '^spot:' /etc/passwd ; then
	busybox chown -h -R spot:spot rootfs-complete/home/spot
fi

(
	cd rootfs-complete
	echo "$EXTRA_COMMANDS" | while read i ; do eval $i ; done
)

rm -rf rootfs-complete/tmp/* #121123 some above chroot operations may have left something behind in here.

## $DEFAULTAPPS - build.conf
echo "Setting default apps specified in build.conf ..."
echo "$DEFAULTAPPS" | sed -e '/^$/d' | \
while IFS="=" read -r field value
do
	[ "$field" = "" -o "$value" = "" ] && continue
	if [ "$value" = "rox" ] ; then
		value=roxfiler
	fi
	DRV_TGT=rootfs-complete NICE_TGT=main
	echo "$ADRV_INC" | grep -q "${value%% *}" && DRV_TGT=adrv NICE_TGT=adrive # determine if app is on main sfs or adrv (not allowed in ydrv,fdrv)
	echo "$field -> $value ($NICE_TGT sfs)"
	[ -e "$DRV_TGT/usr/local/bin/" ] || mkdir -p ${DRV_TGT}/usr/local/bin/ # may not exist on adrv
	echo "#!/bin/sh
exec $value \"\$@\"" > ${DRV_TGT}/usr/local/bin/$field
	chmod 755 ${DRV_TGT}/usr/local/bin/$field
done

BUILD_SFS='yes'

if [ "$SDFLAG" != "" -a "$SDFLAG" != "zip" ]; then
	BUILD_SFS='no'
fi
echo
echo
if [ "$BUILD_SFS" = 'yes' ];then
	if [ -z "$NONFREE_FW" -a "$KFDRIVE" = no ];then
		echo "You now have the opportunity to grab some non-free firmware
to include in ${FDRVSFS}. There is a file in
 'support/fw.conf' 
to configure what firmwares are included. Just set whatever 
you like to 'true' or 'false'.

Do you want to grab extra non-free firmware?
(type 'y' and press 'enter' if you wish or 'enter' to skip..)"
		read nonfree
		case $nonfree in y|Y)
			cd $WKGDIR
			echo; echo
			support/get_fw 
			echo; echo
			cd - ;;
		esac
	else
		if [ "$NONFREE_FW" = 'yes' -a "$KFDRIVE" = no ];then
			cd $WKGDIR
			echo
			echo "grabbing extra non-free firmware..."
			echo; echo
			support/get_fw
			echo; echo
			cd -
		fi
	fi
fi

#-------------------------
#before building puppy.sfs from rootfs-complete, check for any invalid symlinks
#and move them to the devx...
echo
if [ "$WOOF_HOSTARCH" = "$WOOF_TARGETARCH" ] ; then
	echo "Finding invalid symlinks..."
	dirs=$(ls -d rootfs-complete/* | sed -e 's|^rootfs-complete||' | grep -vE '/dev/|/proc/|/sys/') #|/initrd/|/tmp/|/var/|/run/|/mnt/
	#chroot rootfs-complete find -L $dirs -type l > /tmp/invalidsymlinks
	chroot rootfs-complete find $dirs -type l ! -exec test -e {} \; -print > /tmp/invalidsymlinks
	#/usr/local/lib/X11/pixmaps: these images created 1st boot... (was in the old code)
	cat /tmp/invalidsymlinks | sed '\|lib/X11/pixmaps|d' | \
	while read ONESYMLINK ; do
		UPONE=${ONESYMLINK%/*} #dirname ONESYMLINK
		mkdir -p devx${UPONE}
		cp -a -f "rootfs-complete${ONESYMLINK}" devx${UPONE}/
		rm -f "rootfs-complete$ONESYMLINK"
	done
fi

sync

if [ "$BUILD_SFS" = 'yes' ]; then
	files2delete rootfs-complete
	#-----------------------------------------
	../support/rootfs-hacks.sh rootfs-complete
	#-----------------------------------------
	#build the rootfs-complete sfs...
	echo
	echo "Now building the main f.s., ${PUPPYSFS}..."
	sync
	rm -f build/${PUPPYSFS} 2>/dev/null
	mksquashfs rootfs-complete build/${PUPPYSFS} ${SFSCOMP} #100911 110713
	sync
	###########
	if [ -d adrv -o -d fdrv -o -d ydrv ];then
		###########
		#build the {a,f,y}drive sfs...
		for SYS_SFS in adrv fdrv ydrv
		do
			[ ! -d "$SYS_SFS" ] && echo "no $SYS_SFS" && continue
			case $SYS_SFS in
				adrv) TYPE_SYS_SFS="${ADRVSFS}";;
				fdrv) TYPE_SYS_SFS="${FDRVSFS}";;
				ydrv) TYPE_SYS_SFS="${YDRVSFS}";;
			esac
			echo
			echo "Now building the $SYS_SFS f.s., $TYPE_SYS_SFS ..."
			sync
			rm -f build/${TYPE_SYS_SFS} 2>/dev/null
			mksquashfs $SYS_SFS build/${TYPE_SYS_SFS} ${SFSCOMP} #170330
			sync
		done
		###########	
	fi
fi # if BUILD_SFS

#==================================================================================
# DEVX.SFS

#now do the devx...
case $BUILD_DEVX in #_00build.conf
	yes|no) echo -n ;;
	*) BUILD_DEVX=yes ;;
esac

if [ "$BUILD_DEVX" = "yes" ] ; then
	cd $WKGDIR
	echo
	echo "Building ${DEVXSFS}..."
	echo " building sandbox3/devx ..."
	echo "$PKGS_SPECS_TABLE" | grep '^yes' | cut -f 2 -d '|' | sed -e 's%$%_DEV%' > /tmp/ALLGENNAMESD
	##rm -f ./${WOOF_OUTPUT}/${DEVXSFS} 2>/dev/null #100911
	rm -f ./sandbox3/${DEVXSFS} 2>/dev/null #100911
	for ONEDEV in `ls -1 packages-${DISTRO_FILE_PREFIX} | grep '_DEV$' | tr '\n' ' '`
	do
		if grep -q -m1 "^$ONEDEV" /tmp/ALLGENNAMESD ;then
			cp -a --remove-destination packages-${DISTRO_FILE_PREFIX}/${ONEDEV}/* sandbox3/devx/
			sync
		fi
	done
	rm -f /tmp/ALLGENNAMESD
	sync

	if [ "$WOOF_HOSTARCH" = "$WOOF_TARGETARCH" ] ; then
		#earlier above i moved all invalid symlinks into the devx module, yeah but i
		#think should delete them if they really point nowhere...
		echo " Deleting really invalid symlinks in devx..."
		mkdir layer_top
		if [ "$LAYER_TYPE" = 'overlay' ]; then
			mkdir overlay_workdir
			mount -t overlay overlay -olowerdir=sandbox3/rootfs-complete,upperdir=sandbox3/devx,workdir=overlay_workdir layer_top
		else
			mount -t aufs -o udba=reval,diropq=w,dirs=sandbox3/devx=rw:sandbox3/rootfs-complete=ro layerfs layer_top
		fi
		#--
		dirs=$(ls -d layer_top/* | sed 's|layer_top||' | grep -vE '/dev/|/proc/|/sys/') #|/initrd/|/tmp/|/var/|/run/|/mnt/
		chroot layer_top find -L $dirs -type l -delete
		sync
		umount layer_top  ;  rmdir layer_top
	fi

	./support/rootfs-hacks.sh sandbox3/devx # -- HACKS --

	#100622 remove overhead of this script running every bootup...
	mkdir -p sandbox3/devx/etc/profile.d
	rm -f sandbox3/devx/etc/profile.d/pkgconfig* 2>/dev/null
	PKG_CONFIG_PATH="`find sandbox3/devx/usr/lib sandbox3/devx/opt sandbox3/devx/usr/local/lib -type d -name pkgconfig | sed -e 's%sandbox3/devx%%' | tr '\n' ':'`"
	echo "export PKG_CONFIG_PATH='${PKG_CONFIG_PATH}'" > sandbox3/devx/etc/profile.d/pkgconfig

	#maybe stray /install dir from slackware pkgs...
	rm -rf sandbox3/devx/install sandbox3/devx/pet.specs 2>/dev/null
	sync

	#110429 see above, think want glibc scsi headers in usr/include/scsi...
	if [ -d sandbox3/devx/usr/include/scsi-GLIBC ];then
		#probably have kernel scsi headers in usr/include/scsi, fix...
		cp -a -f sandbox3/devx/usr/include/scsi-GLIBC/* sandbox3/devx/usr/include/scsi/
	fi

	# 151019 - delete duplicate symlinks
	echo "deleting duplicate symlinks"
	find sandbox3/devx -type l | \
	while read ONESYMLINK ; do
		# if the symlink exists in sandbox3/rootfs-complete we delete it
		ESYMLINK=${ONESYMLINK//devx/rootfs-complete}
		[ -h "$ESYMLINK" ] && echo -n "$ONESYMLINK " && rm -f "$ONESYMLINK"
	done
	sync
	# do same for duplicates in /etc
	echo -e "\ndeleting duplicate entries in /etc"
	find sandbox3/devx/etc -type f | \
	while read ONEDUPE ; do
		EDUPE=${ONEDUPE//devx/rootfs-complete}
		[ -f "$EDUPE" ] && echo -n "$ONEDUPE " && rm -f "$ONEDUPE"
	done
	sync

	echo -e "\ncleaning out whiteouts"
	clean_out_whiteouts $sandbox3/devx # _00func

	files2delete sandbox3/devx
	for i in usr/share/gtk-doc usr/share/doc/*-dev usr/share/doc/*-common
	do
		rm -rf sandbox3/devx/${i}
	done

	echo "Now creating ${DEVXSFS} ..."
	mksquashfs sandbox3/devx ./sandbox3/${DEVXSFS} ${SFSCOMP} #100911 110713
	sync
	chmod 644 ./sandbox3/${DEVXSFS}
	echo "...done"

	cd sandbox3
fi

#==================================================================================
# ISO file

if [ "$SDFLAG" = "" ];then #120506
	UFLG=''
	if [ "$(ls rootfs-complete/usr/share/grub2-efi/grub*.efi* 2>/dev/null)" ] ; then
		UFLG=-uefi
	fi
	if [ "$BUILD_DEVX" = "yes" -a -f ${DEVXSFS} ] ; then
		if [ "$DEVX_IN_ISO" = "yes" ] ; then #_00build.conf
			XTRA_FLG="${XTRA_FLG}-devx"
			mv -f ${DEVXSFS} ./build/
		else
			WOOF_OUTPUT="woof-output-${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}${UFLG}${XTRA_FLG}"
			[ -d ../$WOOF_OUTPUT ] || mkdir -p ../$WOOF_OUTPUT
			mv -f ${DEVXSFS} ../${WOOF_OUTPUT}/
			( cd ../${WOOF_OUTPUT} ; md5sum ${DEVXSFS} > ${DEVXSFS}.md5.txt )
		fi
	fi

	WOOF_OUTPUT="woof-output-${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}${UFLG}${XTRA_FLG}"
	[ -d ../$WOOF_OUTPUT ] || mkdir -p ../$WOOF_OUTPUT

	# new 160404 UEFI iso - see support/mk_iso.sh
	../support/mk_iso.sh
	uret=$?
	if [ $uret -ne 0 ];then
		echo "mk_iso.sh exited with $uret exit value. 
Aborting
Check the script support/mk_iso.sh to see what this means."
		exit 1
	fi
fi

#==================================================================================

if [ "$SDFLAG" = "zip" ];then
	../support/arm_zip_file.sh
	if [ -f build/${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}.zip ];then
		if [ "$ADD_GIT_HASH_TO_FILENAME" = "yes" ]; then
			GIT_HASH="${BUILD_FROM_WOOF#*;}"
			GIT_HASH="${GIT_HASH%%;*}"
			ZIPNAME="${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}-${GIT_HASH}.zip"
			mv -f build/${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}.zip ../${WOOF_OUTPUT}/${ZIPNAME}
		else
			ZIPNAME="${DISTRO_FILE_PREFIX}-${DISTRO_VERSION}.zip"
			mv -f build/${ZIPNAME} ../${WOOF_OUTPUT}/
		fi
		( cd ../${WOOF_OUTPUT} ; md5sum ${ZIPNAME} > ${ZIPNAME}.md5.txt )
		if [ -f ${DEVXSFS} ]; then
			mv -f ${DEVXSFS} ../${WOOF_OUTPUT}/
			( cd ../${WOOF_OUTPUT} ; md5sum ${DEVXSFS} > ${DEVXSFS}.md5.txt )
		fi
	fi

elif [ "$SDFLAG" ];then #120506 sd image

	# $SD_IMAGE in _00build.conf
	. ../support/arm_sd_image.sh

fi

beep ; beep ; beep
echo -e "\nScript finished."
[ "$WOOF_GUI" ] && { echo -n "Press ENTER key to exit: " ; read zzz ; }

###END###
